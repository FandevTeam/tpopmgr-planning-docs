# แนวทางการทำความเข้าใจเรื่องเวลา (Time) และ MonoBehaviour ใน Unity สำหรับ TPop Manager (ฉบับเบื้องต้น)

เอกสารนี้จัดทำขึ้นเพื่อเป็นแนวทางเบื้องต้นในการทำความเข้าใจและพัฒนาระบบเวลาในเกม TPop Manager และทำความรู้จักกับส่วนสำคัญของ MonoBehaviour โดยมีเป้าหมายให้ทั้งทีมเข้าใจภาพรวมและหลักการทำงานที่สำคัญ

-----

## 1\. เวลา (Time) ใน Unity คืออะไร?

ลองนึกภาพว่าเกม TPop Manager ของเราเหมือนกับ **"โลกเสมือนจริง"** ใบหนึ่งที่กำลังดำเนินไป

  * **Time** ก็เปรียบเสมือน **"นาฬิกาประจำโลก"** หรือ **"เครื่องควบคุมความเร็วของเวลา"** ในโลกเสมือนจริงของเรานั่นแหละจ้ะ\! มันไม่ได้บอกแค่ว่าตอนนี้เวลาผ่านไปเท่าไหร่แล้ว แต่ยังควบคุมได้ด้วยว่าเวลาในเกมจะเดินเร็วแค่ไหน จะหยุดนิ่ง หรือจะเดินช้าลง

  * **หน้าที่หลัก:** จัดการและให้ข้อมูลเกี่ยวกับเวลาที่ผ่านไปในเกม รวมถึงควบคุมความเร็วของเวลาด้วย

  * **ทำไมต้องมี?**

      * **ควบคุมความเร็ว:** ให้เราปรับได้ว่าอยากให้เกมเดินเร็วหรือช้า เช่น เวลาผ่านไป 1 วินาทีในชีวิตจริง เกมอาจจะผ่านไป 1 ชั่วโมงก็ได้
      * **การเคลื่อนไหวที่ราบรื่น:** ช่วยให้การเคลื่อนไหวของสิ่งต่างๆ ในเกมไม่กระตุก ไม่ว่าจะเครื่องคอมพิวเตอร์ช้าหรือเร็ว
      * **จัดการเหตุการณ์:** ใช้จับเวลาเพื่อเกิดเหตุการณ์ต่างๆ ในเกม เช่น ศิลปินฝึกเสร็จเมื่อครบเวลาที่กำหนด

-----

## 2\. MonoBehaviour คืออะไร และทำไมถึงสำคัญกับเวลา?

  * **MonoBehaviour (โมโนบีเฮฟเวียร์):** เปรียบเสมือน **"สิ่งมีชีวิต"** หรือ **"วัตถุ"** ต่างๆ ที่อยู่ในโลกของเกม TPop Manager ของเรานั่นแหละจ้ะ\! ไม่ว่าจะเป็นศิลปิน, ตึกสำนักงาน, รถยนต์, หรือแม้แต่ปุ่มในหน้าจอเกม ทุกอย่างที่เคลื่อนไหว โต้ตอบ หรือต้องทำงานอะไรบางอย่าง มักจะต้องมี "วิญญาณ" ของ MonoBehaviour สิงอยู่

  * **หน้าที่หลัก:** เป็นพื้นฐานให้วัตถุในเกมของเราสามารถ "มีชีวิต" และ "ทำสิ่งต่างๆ" ได้ เช่น เคลื่อนที่, รับการกดปุ่ม, หรือตอบสนองต่อเวลาที่ผ่านไป

  * **ทำไมถึงสำคัญกับเวลา?** MonoBehaviour มี "วงจรชีวิต" ของตัวเอง ที่จะถูกเรียกใช้เป็นประจำในแต่ละ "เฟรม" (ภาพนิ่งๆ 1 ภาพของเกม) ซึ่งทำให้มันสามารถ "รับรู้" การเปลี่ยนแปลงของเวลา และทำสิ่งต่างๆ ตามเวลาได้ เช่น การเคลื่อนที่ของศิลปินทุกๆ เฟรม, หรือการอัปเดตสถานะต่างๆ ของเกม

-----

## 3\. หลักการสำคัญทางเทคนิคของ Time (สำหรับโค้ดเดอร์)

มาทำความรู้จักกับคุณสมบัติ (Property/Variable) และการกระทำ (Method) ต่างๆ ของ `Time` กันนะจ๊ะ\!

### คุณสมบัติ (Properties/Variables) ของ `Time`

  * **`Time.time`**

      * **เปรียบเทียบ:** เหมือนกับ **"นาฬิกาจับเวลา"** ที่เริ่มนับตั้งแต่เรา "เปิดเกม" ขึ้นมา ไม่ว่าเกมจะหยุด (Pause) หรือเดินช้าลง นาฬิกาเรือนนี้ก็จะเดินไปเรื่อยๆ ตามเวลาจริง (ยกเว้นเราปรับ `Time.timeScale` เป็น 0 มันก็จะหยุด)
      * **ในโค้ด:** เป็นเวลาที่ผ่านไปเป็นวินาทีตั้งแต่เริ่มเกม โดยจะได้รับผลกระทบจาก `Time.timeScale`
      * **การประยุกต์ใช้ใน TPop Manager:** ใช้จับเวลาโดยรวมของเกม เช่น แสดงว่าผู้เล่นใช้เวลาเล่นเกมนี้ไปนานเท่าไหร่แล้ว หรือใช้เป็นค่าอ้างอิงสำหรับเหตุการณ์ที่ไม่ต้องการให้หยุดเมื่อเกมถูก Pause

  * **`Time.timeAsDouble`**

      * **เปรียบเทียบ:** เหมือนกับ `Time.time` เป๊ะเลยจ้ะ\! แต่แม่นยำกว่ามาก เพราะใช้หน่วยวัดที่ละเอียดกว่า ทำให้เหมาะกับการจับเวลาที่ต้องการความเป๊ะสุดๆ
      * **ในโค้ด:** เหมือน `Time.time` แต่เป็นชนิด `double` เพื่อความแม่นยำสูง
      * **การประยุกต์ใช้ใน TPop Manager:** ถ้ามีระบบที่ต้องคำนวณเวลาที่ละเอียดมากๆ เช่น การคำนวณผลตอบแทนของศิลปินตามวินาทีที่ทำงาน หรือการจับเวลาในการผลิตเพลงที่ต้องแม่นยำระดับเสี้ยววินาที

  * **`Time.deltaTime`**

      * **เปรียบเทียบ:** เหมือน **"ระยะเวลาที่ผ่านไปแค่ช่วงสั้นๆ"** ระหว่างภาพนิ่ง 2 ภาพ (เฟรม) ติดกัน เช่น ถ้าเฟรมแรกเป็นวินาทีที่ 1.00 และเฟรมถัดมาเป็น 1.05 ค่า `deltaTime` ก็คือ 0.05 วินาที มันสำคัญมากเพราะคอมพิวเตอร์แต่ละเครื่องเร็วไม่เท่ากัน ถ้าเราใช้ `deltaTime` การเคลื่อนไหวของศิลปินก็จะดูราบรื่นไม่ว่าจะคอมใคร
      * **ในโค้ด:** เวลาเป็นวินาทีที่ผ่านไประหว่างเฟรมล่าสุดกับเฟรมก่อนหน้า ได้รับผลกระทบจาก `Time.timeScale`
      * **การประยุกต์ใช้ใน TPop Manager:** ใช้ในการเคลื่อนที่ของตัวละครหรือสิ่งของต่างๆ ในเกมเพื่อให้การเคลื่อนไหวดูเป็นธรรมชาติ ไม่ว่าเฟรมเรตจะสูงหรือต่ำ เช่น `Artist.position += direction * speed * Time.deltaTime;`

  * **`Time.unscaledDeltaTime`**

      * **เปรียบเทียบ:** เหมือน `deltaTime` เลย แต่ **"ไม่สน"** การปรับความเร็วของเวลา (TimeScale) คือไม่ว่าจะตั้ง `Time.timeScale` เป็น 0 เกมหยุดนิ่ง แต่ `unscaledDeltaTime` ก็ยังคงบอกเวลาที่ผ่านไปจริงๆ ระหว่างเฟรมอยู่
      * **ในโค้ด:** เวลาเป็นวินาทีที่ผ่านไประหว่างเฟรมล่าสุดกับเฟรมก่อนหน้า โดยไม่ได้รับผลกระทบจาก `Time.timeScale`
      * **การประยุกต์ใช้ใน TPop Manager:** ใช้สำหรับส่วนที่ต้องการให้ทำงานต่อไปแม้เกมจะถูก Pause หรือปรับความเร็ว เช่น ตัวนับถอยหลังใน UI เมนู Pause, เอฟเฟกต์บางอย่างที่ต้องแสดงผลต่อเนื่อง

  * **`Time.unscaledTime`**

      * **เปรียบเทียบ:** เหมือน `Time.time` เลยจ้ะ\! แต่ **"ไม่สน"** การปรับความเร็วของเวลา (TimeScale) มันจะนับเวลาจริงตั้งแต่เริ่มเกมไปเรื่อยๆ
      * **ในโค้ด:** เวลาเป็นวินาทีตั้งแต่เริ่มเกม โดยไม่ได้รับผลกระทบจาก `Time.timeScale`
      * **การประยุกต์ใช้ใน TPop Manager:** คล้ายกับ `Time.time` แต่ใช้สำหรับจับเวลาในสถานการณ์ที่ `Time.timeScale` อาจมีการเปลี่ยนแปลงบ่อยๆ หรือต้องการเวลาที่เที่ยงตรงตามเวลาจริงเสมอ เช่น ระบบบันทึกเวลาการเล่นทั้งหมดของผู้เล่น หรือฟังก์ชันจับเวลาในหน้าจอตั้งค่าเกม

  * **`Time.unscaledTimeAsDouble`**

      * **เปรียบเทียบ:** เหมือน `Time.unscaledTime` แต่แม่นยำกว่า
      * **ในโค้ด:** เหมือน `Time.unscaledTime` แต่เป็นชนิด `double`
      * **การประยุกต์ใช้ใน TPop Manager:** ถ้าต้องการความแม่นยำสูงมากๆ สำหรับการจับเวลาแบบไม่ได้รับผลกระทบจาก `Time.timeScale`

  * **`Time.fixedDeltaTime`**

      * **เปรียบเทียบ:** เหมือน `deltaTime` แต่เป็น **"ระยะเวลาที่ถูกกำหนดไว้ตายตัว"** สำหรับการคำนวณที่เกี่ยวข้องกับฟิสิกส์ ลองนึกภาพว่าเราเตะบอลในเกม ถ้าเราใช้ `deltaTime` แล้วคอมคนเล่นเกมช้า ลูกบอลอาจจะทะลุสิ่งกีดขวางไปเลย แต่ถ้าใช้ `fixedDeltaTime` ไม่ว่าคอมจะเร็วหรือช้า การชนกันของลูกบอลกับสิ่งของก็จะแม่นยำเหมือนเดิม
      * **ในโค้ด:** เวลาเป็นวินาทีที่ผ่านไปสำหรับแต่ละ Fixed Frame Rate Update ได้รับผลกระทบจาก `Time.timeScale`
      * **การประยุกต์ใช้ใน TPop Manager:** ใช้สำหรับการคำนวณที่เกี่ยวข้องกับฟิสิกส์และระบบที่ต้องทำงานด้วยความถี่ที่แน่นอน เช่น การคำนวณการชนกันของวัตถุ, การเคลื่อนที่ของตัวละครที่ใช้ `Rigidbody` (ระบบฟิสิกส์ของ Unity)

  * **`Time.fixedUnscaledDeltaTime`**

      * **เปรียบเทียบ:** เหมือน `fixedDeltaTime` แต่ **"ไม่สน"** `Time.timeScale`
      * **ในโค้ด:** เหมือน `fixedDeltaTime` แต่ไม่ได้รับผลกระทบจาก `Time.timeScale`
      * **การประยุกต์ใช้ใน TPop Manager:** ถ้ามีระบบฟิสิกส์ที่ต้องการให้ทำงานต่อไปแม้เกมจะถูก Pause หรือปรับความเร็ว

  * **`Time.fixedTime`**

      * **เปรียบเทียบ:** เหมือน **"นาฬิกาจับเวลา"** ที่เดินไปเรื่อยๆ เฉพาะตอนที่ระบบฟิสิกส์ทำงานเท่านั้น
      * **ในโค้ด:** เวลาสะสมเป็นวินาทีตั้งแต่เริ่มเกม ที่ผ่านไปในการอัปเดตฟิสิกส์ ได้รับผลกระทบจาก `Time.timeScale`
      * **การประยุกต์ใช้ใน TPop Manager:** ใช้สำหรับเหตุการณ์ที่ผูกติดกับการอัปเดตฟิสิกส์เท่านั้น

  * **`Time.fixedTimeAsDouble`**

      * **เปรียบเทียบ:** เหมือน `Time.fixedTime` แต่แม่นยำกว่า
      * **ในโค้ด:** เหมือน `Time.fixedTime` แต่เป็นชนิด `double`
      * **การประยุกต์ใช้ใน TPop Manager:** เหมือน `Time.fixedTime` แต่ต้องการความแม่นยำสูง

  * **`Time.maximumDeltaTime`**

      * **เปรียบเทียบ:** เหมือน **"เพดานสูงสุด"** ของ `deltaTime` ปกติแล้วถ้าคอมค้างนานๆ `deltaTime` จะพุ่งสูงมาก ทำให้สิ่งของในเกมกระโดดหรือเคลื่อนที่ผิดปกติ `maximumDeltaTime` ช่วยป้องกันปัญหานี้ โดยการจำกัดค่าสูงสุดของ `deltaTime`
      * **ในโค้ด:** เป็นค่าสูงสุดที่ `deltaTime` จะเป็นได้ ใช้ป้องกันปัญหาเฟรมเรตตกฮวบฮาบ
      * **การประยุกต์ใช้ใน TPop Manager:** ตั้งค่าเพื่อป้องกันไม่ให้การเคลื่อนไหวของศิลปินหรือวัตถุต่างๆ ในเกมกระโดดข้ามไปไกลเกินไปเมื่อเกมเกิดอาการค้างชั่วขณะ ทำให้เกมดูเสถียรขึ้น

  * **`Time.maximumParticleDeltaTime`**

      * **เปรียบเทียบ:** คล้าย `maximumDeltaTime` แต่สำหรับ **"ระบบอนุภาค"** (Particle System) โดยเฉพาะ เช่น ควัน, ฝุ่น, หรือประกายไฟต่างๆ เพื่อไม่ให้เอฟเฟกต์พวกนี้ดูแปลกๆ ถ้าเฟรมเรตตก
      * **ในโค้ด:** เป็นค่าสูงสุดที่ `deltaTime` จะเป็นได้สำหรับ Particle System
      * **การประยุกต์ใช้ใน TPop Manager:** ช่วยให้เอฟเฟกต์ประกายไฟบนเวทีคอนเสิร์ต หรือควันที่ลอยในฉาก ยังคงดูเป็นธรรมชาติและไม่กระตุก แม้เฟรมเรตของเกมจะตกลง

  * **`Time.realtimeSinceStartup`**

      * **เปรียบเทียบ:** เหมือน **"นาฬิกาประจำเครื่องคอมพิวเตอร์"** ที่เริ่มนับตั้งแต่ตอนที่เรา "เปิดโปรแกรมเกม" ขึ้นมา ไม่ว่าเกมจะหยุดนิ่ง, ปรับความเร็ว หรืออะไรก็ตาม นาฬิกาเรือนนี้จะเดินไปตามเวลาจริงของเครื่องคอมพิวเตอร์เสมอ
      * **ในโค้ด:** เวลาเป็นวินาทีตั้งแต่ Unity Editor หรือ Standalone Player เริ่มทำงาน ไม่ได้รับผลกระทบจาก `Time.timeScale`
      * **การประยุกต์ใช้ใน TPop Manager:** ใช้สำหรับจับเวลาที่อยู่นอกเหนือการควบคุมของเกม เช่น ตัวนับเวลาถอยหลังสำหรับโปรโมชั่นพิเศษที่ต้องตรงกับเวลาจริง, หรือใช้ในการส่งข้อมูลไปยัง Server ที่ต้องอาศัยเวลาจริงของโลก

  * **`Time.realtimeSinceStartupAsDouble`**

      * **เปรียบเทียบ:** เหมือน `Time.realtimeSinceStartup` แต่แม่นยำกว่า
      * **ในโค้ด:** เหมือน `Time.realtimeSinceStartup` แต่เป็นชนิด `double`
      * **การประยุกต์ใช้ใน TPop Manager:** เหมือน `Time.realtimeSinceStartup` แต่ต้องการความแม่นยำสูงมาก

  * **`Time.smoothDeltaTime`**

      * **เปรียบเทียบ:** เหมือน `deltaTime` แต่ผ่านการ **"ถัวเฉลี่ย"** ให้ค่าไม่แกว่งมาก เหมือนกับการวิ่งที่บางช่วงอาจจะเร็ว บางช่วงอาจจะช้า แต่ค่า `smoothDeltaTime` จะบอกความเร็วเฉลี่ย ทำให้การเคลื่อนไหวดูนุ่มนวลกว่า
      * **ในโค้ด:** เวลาเป็นวินาทีที่ผ่านไประหว่างเฟรมล่าสุดกับเฟรมก่อนหน้า โดยถูกเฉลี่ยให้ราบรื่น
      * **การประยุกต์ใช้ใน TPop Manager:** ใช้สำหรับการเคลื่อนไหวที่ต้องการความนุ่มนวลเป็นพิเศษ เช่น การเคลื่อนกล้องตามตัวละคร หรือการเคลื่อนที่ของ UI ที่ต้องการให้ดูไหลลื่น

  * **`Time.timeScale`**

      * **เปรียบเทียบ:** เหมือน **"ปุ่มปรับความเร็ว"** ของเกม ถ้าตั้งเป็น 1 เกมก็เดินปกติ, 0.5 เกมก็เดินช้าลงครึ่งนึง, 2 เกมก็เดินเร็วขึ้นสองเท่า, 0 เกมก็หยุดนิ่ง
      * **ในโค้ด:** ค่าที่ใช้ปรับความเร็วของเวลาในเกม มีผลต่อ `Time.deltaTime`, `Time.time`, `Time.fixedDeltaTime`, `Time.fixedTime`
      * **การประยุกต์ใช้ใน TPop Manager:**
          * ปรับเป็น `0` เพื่อ Pause เกมเมื่อผู้เล่นเปิดหน้าต่างเมนู
          * ปรับเป็น `2` หรือ `3` เพื่อเร่งความเร็วของเกม ให้วันเวลาในเกมผ่านไปเร็วขึ้น (เช่น ฟังก์ชัน "เล่นเร็ว" เพื่อให้ผู้เล่นไม่ต้องรอนาน)

  * **`Time.timeSinceLevelLoad`**

      * **เปรียบเทียบ:** เหมือน **"นาฬิกาจับเวลา"** ที่เริ่มนับใหม่ทุกครั้งที่เรา "เปลี่ยนฉาก" (Scene) ในเกม เช่น พอโหลดฉากออฟฟิศปุ๊บ นาฬิกาก็เริ่มนับ 0 ใหม่
      * **ในโค้ด:** เวลาเป็นวินาทีที่ผ่านไปตั้งแต่ Scene ปัจจุบันถูกโหลด
      * **การประยุกต์ใช้ใน TPop Manager:** ใช้สำหรับเหตุการณ์ที่ต้องเกิดขึ้นหลังจากโหลดฉากนั้นๆ มาแล้วเป็นเวลาหนึ่ง เช่น การแสดง Tutorial หลังจากผู้เล่นเข้าสู่ฉากฝึกสอนเป็นเวลา 5 วินาที

  * **`Time.timeSinceLevelLoadAsDouble`**

      * **เปรียบเทียบ:** เหมือน `Time.timeSinceLevelLoad` แต่แม่นยำกว่า
      * **ในโค้ด:** เหมือน `Time.timeSinceLevelLoad` แต่เป็นชนิด `double`
      * **การประยุกต์ใช้ใน TPop Manager:** เหมือน `Time.timeSinceLevelLoad` แต่ต้องการความแม่นยำสูง

  * **`Time.frameCount`**

      * **เปรียบเทียบ:** เหมือน **"จำนวนภาพนิ่ง"** (เฟรม) ทั้งหมดที่เกมแสดงผลไปแล้วตั้งแต่เริ่มเกม ทุกครั้งที่เกมวาดภาพใหม่ 1 ครั้ง ค่านี้ก็จะเพิ่มขึ้น 1
      * **ในโค้ด:** จำนวนเฟรมที่แสดงผลไปแล้วทั้งหมดตั้งแต่เริ่มเกม
      * **การประยุกต์ใช้ใน TPop Manager:** ใช้สำหรับคำนวณเฟรมเรตของเกม หรือใช้เป็นตัวจับเวลาแบบหยาบๆ สำหรับเหตุการณ์ที่ไม่ต้องการความแม่นยำสูงมากนัก

  * **`Time.inFixedTimeStep`**

      * **เปรียบเทียบ:** เหมือน **"ป้ายบอกทาง"** ที่บอกว่าตอนนี้เรากำลังอยู่ในช่วงเวลาที่ระบบฟิสิกส์กำลังทำงานอยู่หรือไม่
      * **ในโค้ด:** เป็น `true` ถ้าโค้ดกำลังรันอยู่ใน FixedUpdate หรือ Callback ที่เกี่ยวข้องกับฟิสิกส์
      * **การประยุกต์ใช้ใน TPop Manager:** ใช้ตรวจสอบว่าโค้ดที่เขียนอยู่นั้นกำลังทำงานในส่วนที่เหมาะสมกับการคำนวณฟิสิกส์หรือไม่ เพื่อหลีกเลี่ยงข้อผิดพลาด

  * **`Time.captureFramerate`**

      * **เปรียบเทียบ:** เหมือน **"เครื่องอัดวิดีโอ"** ที่เราตั้งค่าได้ว่าจะให้อัดภาพนิ่งกี่ภาพต่อวินาที ถ้าเราตั้งค่านี้ Unity จะพยายามรันเกมที่เฟรมเรตที่เรากำหนด เพื่อใช้ในการบันทึกวิดีโอหรือทดสอบ
      * **ในโค้ด:** กำหนดเฟรมเรตที่เกมควรจะทำงานเพื่อการบันทึกวิดีโอ
      * **การประยุกต์ใช้ใน TPop Manager:** ใช้เมื่อต้องการบันทึกวิดีโอของเกมเพลย์หรือ Trailer เพื่อให้ได้วิดีโอที่ลื่นไหลตามเฟรมเรตที่ต้องการ

  * **`Time.captureDeltaTime`**

      * **เปรียบเทียบ:** เหมือน `deltaTime` แต่เป็นค่าที่คำนวณมาจาก `captureFramerate` คือถ้าเราบอกว่าจะอัดที่ 30 เฟรมต่อวินาที `captureDeltaTime` ก็จะเป็น 1/30 (ประมาณ 0.033) เสมอ
      * **ในโค้ด:** `deltaTime` ที่ใช้เมื่อ `captureFramerate` ถูกตั้งค่า
      * **การประยุกต์ใช้ใน TPop Manager:** ใช้ในการเคลื่อนไหวที่ต้องสอดคล้องกับการบันทึกวิดีโอ เพื่อให้ภาพที่ได้จากวิดีโอมีความสม่ำเสมอ

  * **`Time.captureDeltaTimeRational`**

      * **เปรียบเทียบ:** เหมือน `captureDeltaTime` แต่บอกค่าเป็น "เศษส่วน" ที่แม่นยำกว่า เช่น 1/30 แทนที่จะเป็น 0.03333333
      * **ในโค้ด:** เหมือน `captureDeltaTime` แต่แสดงผลในรูปของเศษส่วน `Rational` เพื่อความแม่นยำสูงในการจับเวลา
      * **การประยุกต์ใช้ใน TPop Manager:** สำหรับงานที่ต้องการความแม่นยำระดับคณิตศาสตร์สูง เช่น การสร้างเครื่องมือวิเคราะห์ประสิทธิภาพเกม

  * **`Time.timeAsRational`**

      * **เปรียบเทียบ:** เหมือน `Time.time` แต่บอกค่าเป็น "เศษส่วน" ที่แม่นยำกว่า
      * **ในโค้ด:** เหมือน `Time.time` แต่แสดงผลในรูปของเศษส่วน `Rational`
      * **การประยุกต์ใช้ใน TPop Manager:** สำหรับงานที่ต้องการความแม่นยำระดับคณิตศาสตร์สูงในการจับเวลาเกม

### เมธอด (Methods) ของ `Time`

  * (ไม่มีเมธอดที่สำคัญในคลาส `Time` โดยตรงที่ต้องอธิบายสำหรับผู้ที่ไม่เชี่ยวชาญ)

-----

## 4\. วงจรชีวิต (Lifecycle) ของ MonoBehaviour ที่เกี่ยวข้องกับเวลา (สำหรับโค้ดเดอร์)

MonoBehaviour มี "ช่วงชีวิต" ของมันเอง ที่จะถูกเรียกใช้โดย Unity ในช่วงเวลาที่เหมาะสม โดยเฉพาะฟังก์ชันเหล่านี้ที่เกี่ยวข้องกับเวลามากๆ:

  * **`Update()`**

      * **เปรียบเทียบ:** เหมือนกับ **"การทำงานประจำวัน"** ของพนักงานทุกคนในบริษัท ทุกๆ "เฟรม" (ภาพใหม่ที่เกมแสดงผล) พนักงานทุกคนที่มีหน้าที่นี้ก็จะถูกเรียกให้ทำงาน 1 ครั้ง
      * **ในโค้ด:** ฟังก์ชันที่ถูกเรียกในทุกๆ เฟรม ใช้สำหรับอัปเดตสถานะของเกม, การเคลื่อนไหวของตัวละคร, การรับ Input จากผู้เล่น **ได้รับผลกระทบจาก `Time.timeScale`**
      * **การประยุกต์ใช้ใน TPop Manager:**
          * การเคลื่อนที่ของศิลปินบนเวที
          * นับเวลาถอยหลังสำหรับกิจกรรมประจำวันในเกม (เช่น เหลือเวลาอีกกี่วินาทีจะถึงเที่ยงคืน)
          * การตอบสนองต่อการคลิกเมาส์หรือกดปุ่มของผู้เล่น

  * **`FixedUpdate()`**

      * **เปรียบเทียบ:** เหมือนกับ **"การประชุมประจำสัปดาห์"** ของแผนกบัญชีหรือวิศวกร การประชุมนี้จะเกิดขึ้นในเวลาที่ "กำหนดไว้ตายตัว" เสมอ ไม่ว่าจะเกิดอะไรขึ้นก็ตาม เพื่อให้การคำนวณที่สำคัญ เช่น งบประมาณ หรือโครงสร้างอาคาร เป็นไปอย่างแม่นยำ
      * **ในโค้ด:** ฟังก์ชันที่ถูกเรียกตามช่วงเวลาที่แน่นอน (Fixed Timestep) โดยไม่ขึ้นกับเฟรมเรตของเกม เหมาะสำหรับโค้ดที่เกี่ยวข้องกับฟิสิกส์ (Rigidbody) และการคำนวณที่ต้องการความสม่ำเสมอ **ได้รับผลกระทบจาก `Time.timeScale`**
      * **การประยุกต์ใช้ใน TPop Manager:**
          * การคำนวณการเคลื่อนที่ของรถยนต์ขนส่งศิลปินที่ใช้ระบบฟิสิกส์
          * การคำนวณการชนกันของวัตถุในฉาก
          * อัปเดตค่าต่างๆ ที่ต้องเป็นไปตามตรรกะที่แน่นอน เช่น การคำนวณรายได้ประจำวันของบริษัท

  * **`LateUpdate()`**

      * **เปรียบเทียบ:** เหมือนกับ **"การสรุปงาน"** ในตอนท้ายของวัน พนักงานทุกคนทำหน้าที่ `Update()` ไปแล้ว จากนั้นก็มาสรุปงานอีกที เช่น กล้องจะเคลื่อนตามตัวละคร ก็ควรมองหลังจากที่ตัวละครเคลื่อนที่ใน `Update()` เสร็จแล้ว
      * **ในโค้ด:** ฟังก์ชันที่ถูกเรียกหลังจาก `Update()` ของทุกๆ Script ในเฟรมนั้นๆ ใช้สำหรับโค้ดที่ต้องทำงานหลังจากการอัปเดตอื่นๆ เสร็จสิ้น **ได้รับผลกระทบจาก `Time.timeScale`**
      * **การประยุกต์ใช้ใน TPop Manager:**
          * การเคลื่อนกล้องติดตามศิลปินที่กำลังเดินไปมา
          * อัปเดต UI ที่แสดงค่าบางอย่างที่เพิ่งถูกคำนวณใน `Update()`

-----

## 5\. การประยุกต์ใช้ในเกม TPop Manager

เพื่อให้เห็นภาพชัดเจนขึ้น ลองดูตัวอย่างการนำ Time และ MonoBehaviour ไปใช้ใน TPop Manager กันนะจ๊ะ\!

### ตัวอย่าง: การปรับความเร็วเวลาใน TPop Manager

สมมติว่าผู้เล่นต้องการเร่งวันเวลาในเกมให้ผ่านไปเร็วขึ้น เพื่อให้ศิลปินฝึกได้เร็ว หรือสร้างตึกเสร็จเร็วขึ้น:

```csharp
// ใน GameCoreManager.cs หรือ Manager ที่จัดการการตั้งค่าเกม
public class GameCoreManager : Singleton<GameCoreManager>
{
    // เมธอดสำหรับปรับความเร็วของเกม
    public void SetGameSpeed(float speedMultiplier)
    {
        Time.timeScale = speedMultiplier; // ปรับ Time.timeScale
        Debug.Log($"ปรับความเร็วเกมเป็น x{speedMultiplier} แล้ว!");
    }

    // ตัวอย่างการใช้งาน:
    void Update()
    {
        // ถ้าผู้เล่นกดปุ่ม '1' ให้เกมเดินปกติ
        if (Input.GetKeyDown(KeyCode.Alpha1))
        {
            SetGameSpeed(1f);
        }
        // ถ้าผู้เล่นกดปุ่ม '2' ให้เกมเดินเร็วขึ้น 2 เท่า
        if (Input.GetKeyDown(KeyCode.Alpha2))
        {
            SetGameSpeed(2f);
        }
        // ถ้าผู้เล่นกดปุ่ม 'Spacebar' ให้เกมหยุดชั่วคราว (Pause)
        if (Input.GetKeyDown(KeyCode.Space))
        {
            SetGameSpeed(0f);
        }
    }
}
```

  * **คำอธิบาย:** เมื่อ `Time.timeScale` ถูกปรับ ค่า `Time.deltaTime` และ `Time.fixedDeltaTime` จะเปลี่ยนไปด้วย ทำให้ทุกอย่างที่ใช้ค่าเหล่านี้ (เช่น การเคลื่อนที่ของศิลปิน, การนับเวลาในเกม) เดินเร็วขึ้นหรือช้าลงตามที่ตั้งไว้

### ตัวอย่าง: การนับเวลาการฝึกฝนศิลปิน

สมมติว่าศิลปินต้องใช้เวลาฝึกฝน 10 วินาทีในเกม:

```csharp
// ใน ArtistProfileManager.cs
public class ArtistProfileManager : Singleton<ArtistProfileManager>, IArtistDataProvider
{
    // ... (โค้ดเดิม) ...

    public event Action<int> OnArtistTrainingCompleted; // Event เมื่อฝึกฝนศิลปินเสร็จ

    public void TrainArtist(int artistId)
    {
        ArtistData artist = Artists.Find(a => a.id == artistId);
        if (artist != null)
        {
            Debug.Log($"เริ่มฝึกฝน {artist.artistName} แล้ว... รอ 10 วินาทีในเกม");
            // เราสามารถใช้ Coroutine หรือจับเวลาใน Update ได้
            // สำหรับตัวอย่างนี้จะใช้ Coroutine เพื่อให้เห็นภาพง่ายขึ้น
            StartCoroutine(DoTraining(artist.id, 10f)); // ฝึก 10 วินาที
        }
    }

    private System.Collections.IEnumerator DoTraining(int artistId, float duration)
    {
        float timer = 0f;
        while (timer < duration)
        {
            timer += Time.deltaTime; // นับเวลาตาม deltaTime เพื่อให้สอดคล้องกับ TimeScale
            yield return null; // รอ 1 เฟรม
        }

        // เมื่อเวลาครบ
        ArtistData artist = Artists.Find(a => a.id == artistId);
        if (artist != null)
        {
            artist.vocalSkill += 5;
            Debug.Log($"[ArtistProfileManager] ฝึกฝน {artist.artistName} เสร็จแล้ว! สกิลร้อง: {artist.vocalSkill}");
            OnArtistTrainingCompleted?.Invoke(artist.id); // ส่ง Event แจ้งว่าฝึกเสร็จ
        }
    }
    // ... (เมธอดอื่นๆ) ...
}
```

  * **คำอธิบาย:** เราใช้ `Time.deltaTime` ใน Coroutine เพื่อให้นับเวลาได้อย่างถูกต้อง แม้ว่าผู้เล่นจะปรับ `Time.timeScale` ให้เร็วขึ้นหรือช้าลง การฝึกฝนก็จะใช้เวลา 10 วินาที "ในเวลาของเกม" เสมอ

### ตัวอย่าง: UI ที่แสดงผลเงินแม้เกมหยุดชั่วคราว

ถ้าเรามี UI ที่แสดงจำนวนเงินในบริษัท และต้องการให้มันอัปเดตทันทีแม้เกมจะถูก Pause

```csharp
// ใน GameUIManager.cs (จากเอกสาร Persistent Manager)
public class GameUIManager : Singleton<GameUIManager>
{
    public TextMeshProUGUI moneyText;

    void OnEnable()
    {
        // สมัครรับ Event เมื่อ GameObject ถูกเปิดใช้งาน
        EnterpriseManager.OnMoneyChanged += UpdateMoneyDisplay;

        // อัปเดตค่าเริ่มต้นเมื่อเปิดใช้งาน (กรณีโหลดเกมหรือเริ่มเกมใหม่)
        if (EnterpriseManager.Instance != null)
        {
            UpdateMoneyDisplay(0, EnterpriseManager.Instance.Money); // Initial update
        }
    }

    void OnDisable()
    {
        // ยกเลิกการรับ Event เมื่อ GameObject ถูกปิดใช้งาน (สำคัญมาก!)
        EnterpriseManager.OnMoneyChanged -= UpdateMoneyDisplay;
    }

    private void UpdateMoneyDisplay(int amountChanged, int currentMoney)
    {
        // การอัปเดต UI ไม่ได้ขึ้นกับ Time.deltaTime โดยตรง
        // แต่ถูกเรียกเมื่อ Event OnMoneyChanged เกิดขึ้น
        // ซึ่ง Event นี้จะถูกเรียกเมื่อ AddMoney/SpendMoney ถูกเรียก
        moneyText.text = $"เงิน: {currentMoney} ({ (amountChanged >= 0 ? "+" : "") }{amountChanged})";
        Debug.Log($"UI แสดง: เงินเปลี่ยนไป {amountChanged}, ปัจจุบันคือ {currentMoney}");
    }

    public void OnClickEarnMoneyButton()
    {
        // ปุ่มนี้สามารถกดได้แม้เกมจะ Pause (Time.timeScale = 0)
        // เพราะการเรียก AddMoney เป็นการเรียกฟังก์ชันตรงๆ ไม่ได้ขึ้นกับการอัปเดตเฟรม
        EnterpriseManager.Instance.AddMoney(100);
    }
}
```

  * **คำอธิบาย:** การใช้ Events (`OnMoneyChanged`) ช่วยให้ UI สามารถอัปเดตได้ทันทีที่ข้อมูลเงินเปลี่ยน ไม่ว่า `Time.timeScale` จะเป็นเท่าไหร่ก็ตาม ทำให้ผู้เล่นยังเห็นการเปลี่ยนแปลงของเงิน แม้จะอยู่ในหน้า Pause หรือเมนูก็ตาม

-----

## สรุป: Time และ MonoBehaviour

การทำความเข้าใจเรื่อง `Time` และวงจรชีวิตของ `MonoBehaviour` เป็นสิ่งสำคัญมากในการพัฒนาเกม Unity โดยเฉพาะเกมอย่าง TPop Manager ที่มีการจัดการเวลาในเกมและการตอบสนองของผู้เล่น การเลือกใช้ Property ของ `Time` และฟังก์ชันของ `MonoBehaviour` ให้ถูกที่ถูกเวลา จะช่วยให้เกมของเรามีความยืดหยุ่น, ราบรื่น, และทำงานได้อย่างถูกต้องจ้ะ\!

-----

**หมายเหตุ:** โค้ดตัวอย่างข้างต้นใช้ `UnityEngine.Debug.Log` สำหรับการแสดงผลใน Console ของ Unity เพื่อให้เห็นภาพการทำงานเบื้องต้น ในการพัฒนาจริง คุณอาจจะใช้ระบบ Log ที่ซับซ้อนกว่านี้
